###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           25/Apr/2016  02:34:35
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.40
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\David\Documents\ECE 306\Project-08 - Copy\command_Structure.c
#    Command line  =  
#        "C:\Users\David\Documents\ECE 306\Project-08 -
#        Copy\command_Structure.c" -lC "C:\Users\David\Documents\ECE
#        306\Project-08 - Copy\Debug\List" -o "C:\Users\David\Documents\ECE
#        306\Project-08 - Copy\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --debug -D__MSP430FR5739__ -e --double=32
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\430\lib\dlib\dl430xlsfn.h" --core=430X --data_model=small -On
#        --multiplier=32 --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        C:\Users\David\Documents\ECE 306\Project-08 -
#        Copy\Debug\List\command_Structure.lst
#    Object file   =  
#        C:\Users\David\Documents\ECE 306\Project-08 -
#        Copy\Debug\Obj\command_Structure.r43
#
###############################################################################

C:\Users\David\Documents\ECE 306\Project-08 - Copy\command_Structure.c
      1          //#include <stdlib.h>
      2          #include "macros.h"
      3          #include "functions.h"
      4          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x5ce
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ee
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2
      5          
      6          //GLOBAL VARIABLES------------------------------------------------------------//
      7          //multi-function globals//
      8          extern char *display_1;
      9          extern char *display_2;
     10          extern char *display_3;
     11          extern char *display_4;
     12          extern volatile unsigned int pressed1;
     13          extern volatile unsigned int pressed2;
     14          
     15          //commandTree() globals//
     16          extern volatile char commandBuffer[MAX_COMMANDBUF_SIZE];
     17          extern volatile unsigned int commandIndex;
     18          extern unsigned int writeCommandFG;
     19          extern unsigned int i,j, k; //counter variable
     20          extern volatile unsigned int transmitReady;
     21          extern volatile unsigned int StartCommandFG;
     22          extern unsigned int macFG;
     23          extern volatile unsigned int IOTIndexReceive; //testing
     24          
     25          //calibrate_detector() globals//
     26          extern unsigned int Ambient_right; //Variables for detector calibration
     27          extern unsigned int Ambient_left;
     28          extern unsigned int White_right;
     29          extern unsigned int White_left;
     30          extern unsigned int Black_right;
     31          extern unsigned int Black_left;
     32          extern unsigned int threshhold;
     33          extern volatile unsigned int Left_Detector;
     34          extern volatile unsigned int Right_Detector;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     35          char numberBuff[MAX_NUMBERBUF_SIZE];
   \                     numberBuff:
   \   000000                DS8 5

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     36          unsigned int time=RESET;
   \                     time:
   \   000000                DS8 2
     37          extern volatile unsigned int right_forward_rate;
     38          extern volatile unsigned int right_reverse_rate;
     39          extern volatile unsigned int left_forward_rate;
     40          extern volatile unsigned int left_reverse_rate;
     41          extern unsigned int thresholdR;
     42          extern unsigned int thresholdL;
     43          extern volatile unsigned int ADC_Left_Detector;
     44          extern volatile unsigned int ADC_Right_Detector;
     45          extern unsigned int start_on_whiteFG;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     46          unsigned int startBlackLine = FALSE;
   \                     startBlackLine:
   \   000000                DS8 2
     47          extern unsigned int startTrackFG;
     48          //----------------------------------------------------------------------------//
     49          
     50          

   \                                 In  segment CODE, align 2
     51          void commandTree(void){
   \                     commandTree:
     52            //==============================================================================
     53            // COMMANDTREE
     54            // 
     55            // Description: This function is used as a command tree for input commands
     56            //
     57            // Passed : no variables passed
     58            // Locals:    none
     59            // Returned: no values returned
     60            // Globals:   left_forward_rate
     61            //            right_forward_rate 
     62            //            left_reverse_rate
     63            //            right_reverse_rate
     64            //            start_on_whiteFG
     65            //            ADC_Left_Detector
     66            //            ADC_Right_Detector
     67            //            thresholdL
     68            //            thresholdR
     69            //            motor_time
     70            //            commandBuffer
     71            //            i, k, j
     72            //            commandIndex
     73            //            StartCommandFG
     74            //            numberBuff
     75            //            display_1
     76            //            time
     77            //            startBlackLine
     78            //            startTrackFG
     79            //            start_on_whiteFG
     80            //
     81            // Author: David Pryor
     82            // Date: April 2016
     83            // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (6.4.1)
     84            //============================================================================== 
     85            commandIndex=RESET;
   \   000000   8243....     MOV.W   #0x0, &commandIndex
     86              for(i=RESET;i<MAX_COMMANDBUF_SIZE;i++){ //clear command buffer
   \   000004   8243....     MOV.W   #0x0, &i
   \                     ??commandTree_0:
   \   000008   B2901E00.... CMP.W   #0x1e, &i
   \   00000E   072C         JC      ??commandTree_8
     87                  commandBuffer[i]='\0';
   \   000010   1F42....     MOV.W   &i, R15
   \   000014   CF43....     MOV.B   #0x0, commandBuffer(R15)
     88                  
     89              }
   \   000018   9253....     ADD.W   #0x1, &i
   \   00001C   F53F         JMP     ??commandTree_0
     90              i=RESET;
   \                     ??commandTree_8:
   \   00001E   8243....     MOV.W   #0x0, &i
     91              writeCommandFG=TRUE; //write to command buffer (in interrupt)
   \   000022   9243....     MOV.W   #0x1, &writeCommandFG
     92              Five_msec_Delay(FOR_FIFTY_MSEC); //short delay to allow for commandBuffer to fill   
   \   000026   3C400A00     MOV.W   #0xa, R12
   \   00002A   ........     CALLA   #Five_msec_Delay
     93              while(commandBuffer[i] != '\r' && commandBuffer[i] != '\n'){ //search through command buffer, and end if carriage return or new line is hit
   \                     ??commandTree_7:
   \   00002E   1F42....     MOV.W   &i, R15
   \   000032   FF900D00.... CMP.B   #0xd, commandBuffer(R15)
   \   000038   ....         JNE     $+6
   \   00003A   ........     BRA     #??commandTree_9
   \   00003E   1F42....     MOV.W   &i, R15
   \   000042   FF900A00.... CMP.B   #0xa, commandBuffer(R15)
   \   000048   ....         JNE     $+6
   \   00004A   ........     BRA     #??commandTree_9
     94                  for(k=RESET;k<MAX_NUMBERBUF_SIZE;k++){
   \   00004E   8243....     MOV.W   #0x0, &k
   \                     ??commandTree_1:
   \   000052   B2900500.... CMP.W   #0x5, &k
   \   000058   072C         JC      ??commandTree_10
     95                      numberBuff[k] = '\0'; //clearing number buffer
   \   00005A   1F42....     MOV.W   &k, R15
   \   00005E   CF43....     MOV.B   #0x0, numberBuff(R15)
     96                  }
   \   000062   9253....     ADD.W   #0x1, &k
   \   000066   F53F         JMP     ??commandTree_1
     97                  if(!(commandBuffer[i+FIRST_ELEMENT]=='4' && commandBuffer[i+SECOND_ELEMENT]=='3' && commandBuffer[i+THIRD_ELEMENT]=='2' && commandBuffer[i+FOURTH_ELEMENT]=='1')){ //if command contains securuty pin, then enter command tree
   \                     ??commandTree_10:
   \   000068   1F42....     MOV.W   &i, R15
   \   00006C   FF903400.... CMP.B   #0x34, commandBuffer(R15)
   \   000072   1220         JNE     ??commandTree_11
   \   000074   1F42....     MOV.W   &i, R15
   \   000078   FF903300.... CMP.B   #0x33, commandBuffer + 1(R15)
   \   00007E   0C20         JNE     ??commandTree_11
   \   000080   1F42....     MOV.W   &i, R15
   \   000084   FF903200.... CMP.B   #0x32, commandBuffer + 2(R15)
   \   00008A   0620         JNE     ??commandTree_11
   \   00008C   1F42....     MOV.W   &i, R15
   \   000090   FF903100.... CMP.B   #0x31, commandBuffer + 3(R15)
   \   000096   0424         JEQ     ??commandTree_12
     98                      StartCommandFG=FALSE;
   \                     ??commandTree_11:
   \   000098   8243....     MOV.W   #0x0, &StartCommandFG
     99                      break;
   \   00009C   ........     BRA     #??commandTree_9
    100                  }
    101                  if(commandBuffer[i+FIFTH_ELEMENT]=='A'){ //checking for .A
   \                     ??commandTree_12:
   \   0000A0   1F42....     MOV.W   &i, R15
   \   0000A4   FF904100.... CMP.B   #0x41, commandBuffer + 4(R15)
   \   0000AA   1C20         JNE     ??commandTree_13
    102                      if(commandBuffer[i+SIXTH_ELEMENT]=='\r' || commandBuffer[i+SIXTH_ELEMENT]=='.' || commandBuffer[i+SIXTH_ELEMENT]=='\n'){ //check for end of a command line
   \   0000AC   1F42....     MOV.W   &i, R15
   \   0000B0   FF900D00.... CMP.B   #0xd, commandBuffer + 5(R15)
   \   0000B6   0E24         JEQ     ??commandTree_14
   \   0000B8   1F42....     MOV.W   &i, R15
   \   0000BC   FF902E00.... CMP.B   #0x2e, commandBuffer + 5(R15)
   \   0000C2   0824         JEQ     ??commandTree_14
   \   0000C4   1F42....     MOV.W   &i, R15
   \   0000C8   FF900A00.... CMP.B   #0xa, commandBuffer + 5(R15)
   \   0000CE   ....         JEQ     $+6
   \   0000D0   ........     BRA     #??commandTree_6
    103                          uart_puts("I'm Here\r");
   \                     ??commandTree_14:
   \   0000D4   3C40....     MOV.W   #`?<Constant "I\\'m Here\\r">`, R12
   \   0000D8   ........     CALLA   #uart_puts
    104                          StartCommandFG=FALSE;
   \   0000DC   8243....     MOV.W   #0x0, &StartCommandFG
   \   0000E0   ........     BRA     #??commandTree_6
    105                      }
    106                  }
    107                  else if(commandBuffer[i+FIFTH_ELEMENT]=='B'){ //Check for baud rate command or reverse command
   \                     ??commandTree_13:
   \   0000E4   1F42....     MOV.W   &i, R15
   \   0000E8   FF904200.... CMP.B   #0x42, commandBuffer + 4(R15)
   \   0000EE   DF20         JNE     ??commandTree_15
    108                    k=RESET;
   \   0000F0   8243....     MOV.W   #0x0, &k
    109                    j=i+SIXTH_ELEMENT;
   \   0000F4   1F42....     MOV.W   &i, R15
   \   0000F8   3F500500     ADD.W   #0x5, R15
   \   0000FC   824F....     MOV.W   R15, &j
    110                    for(;commandBuffer[j]!='\r' &&  commandBuffer[j]!='\n' && commandBuffer[j]!='.';j++){
   \                     ??commandTree_2:
   \   000100   1F42....     MOV.W   &j, R15
   \   000104   FF900D00.... CMP.B   #0xd, commandBuffer(R15)
   \   00010A   5424         JEQ     ??commandTree_16
   \   00010C   1F42....     MOV.W   &j, R15
   \   000110   FF900A00.... CMP.B   #0xa, commandBuffer(R15)
   \   000116   4E24         JEQ     ??commandTree_16
   \   000118   1F42....     MOV.W   &j, R15
   \   00011C   FF902E00.... CMP.B   #0x2e, commandBuffer(R15)
   \   000122   4824         JEQ     ??commandTree_16
    111                      if(commandBuffer[j] == '0' || commandBuffer[j] == '1'|| commandBuffer[j] == '2'|| commandBuffer[j] == '3'|| commandBuffer[j] == '4'|| commandBuffer[j] == '5'|| commandBuffer[j] == '6'|| commandBuffer[j] == '7'|| commandBuffer[j] == '8'|| commandBuffer[j] == '9'){
   \   000124   1F42....     MOV.W   &j, R15
   \   000128   FF903000.... CMP.B   #0x30, commandBuffer(R15)
   \   00012E   3624         JEQ     ??commandTree_17
   \   000130   1F42....     MOV.W   &j, R15
   \   000134   FF903100.... CMP.B   #0x31, commandBuffer(R15)
   \   00013A   3024         JEQ     ??commandTree_17
   \   00013C   1F42....     MOV.W   &j, R15
   \   000140   FF903200.... CMP.B   #0x32, commandBuffer(R15)
   \   000146   2A24         JEQ     ??commandTree_17
   \   000148   1F42....     MOV.W   &j, R15
   \   00014C   FF903300.... CMP.B   #0x33, commandBuffer(R15)
   \   000152   2424         JEQ     ??commandTree_17
   \   000154   1F42....     MOV.W   &j, R15
   \   000158   FF903400.... CMP.B   #0x34, commandBuffer(R15)
   \   00015E   1E24         JEQ     ??commandTree_17
   \   000160   1F42....     MOV.W   &j, R15
   \   000164   FF903500.... CMP.B   #0x35, commandBuffer(R15)
   \   00016A   1824         JEQ     ??commandTree_17
   \   00016C   1F42....     MOV.W   &j, R15
   \   000170   FF903600.... CMP.B   #0x36, commandBuffer(R15)
   \   000176   1224         JEQ     ??commandTree_17
   \   000178   1F42....     MOV.W   &j, R15
   \   00017C   FF903700.... CMP.B   #0x37, commandBuffer(R15)
   \   000182   0C24         JEQ     ??commandTree_17
   \   000184   1F42....     MOV.W   &j, R15
   \   000188   FF903800.... CMP.B   #0x38, commandBuffer(R15)
   \   00018E   0624         JEQ     ??commandTree_17
   \   000190   1F42....     MOV.W   &j, R15
   \   000194   FF903900.... CMP.B   #0x39, commandBuffer(R15)
   \   00019A   0920         JNE     ??commandTree_18
    112                        numberBuff[k] = commandBuffer[j]; // grabbing numbers from command
   \                     ??commandTree_17:
   \   00019C   1F42....     MOV.W   &j, R15
   \   0001A0   1E42....     MOV.W   &k, R14
   \   0001A4   DE4F........ MOV.B   commandBuffer(R15), numberBuff(R14)
    113                        k++;
   \   0001AA   9253....     ADD.W   #0x1, &k
    114                      }
    115                    }
   \                     ??commandTree_18:
   \   0001AE   9253....     ADD.W   #0x1, &j
   \   0001B2   A63F         JMP     ??commandTree_2
    116                    if(commandBuffer[i+SIXTH_ELEMENT]=='F'){ //checking for .BF
   \                     ??commandTree_16:
   \   0001B4   1F42....     MOV.W   &i, R15
   \   0001B8   FF904600.... CMP.B   #0x46, commandBuffer + 5(R15)
   \   0001BE   2220         JNE     ??commandTree_19
    117                        if(commandBuffer[i+SEVENTH_ELEMENT]=='\r' || commandBuffer[i+SEVENTH_ELEMENT]=='.' || commandBuffer[i+SEVENTH_ELEMENT]=='\n'){ //check for end of a command line
   \   0001C0   1F42....     MOV.W   &i, R15
   \   0001C4   FF900D00.... CMP.B   #0xd, commandBuffer + 6(R15)
   \   0001CA   0E24         JEQ     ??commandTree_20
   \   0001CC   1F42....     MOV.W   &i, R15
   \   0001D0   FF902E00.... CMP.B   #0x2e, commandBuffer + 6(R15)
   \   0001D6   0824         JEQ     ??commandTree_20
   \   0001D8   1F42....     MOV.W   &i, R15
   \   0001DC   FF900A00.... CMP.B   #0xa, commandBuffer + 6(R15)
   \   0001E2   ....         JEQ     $+6
   \   0001E4   ........     BRA     #??commandTree_6
    118                          Init_Serial_UCA1(RESET); //set IOT baud to 115200
   \                     ??commandTree_20:
   \   0001E8   0C43         MOV.W   #0x0, R12
   \   0001EA   ........     CALLA   #Init_Serial_UCA1
    119                          display_1 = "  115200  ";
   \   0001EE   B240........ MOV.W   #`?<Constant "  115200  ">`, &display_1
    120                          uart_puts("115,200\n");
   \   0001F4   3C40....     MOV.W   #`?<Constant "115,200\\n">`, R12
   \   0001F8   ........     CALLA   #uart_puts
    121                          StartCommandFG=FALSE;
   \   0001FC   8243....     MOV.W   #0x0, &StartCommandFG
   \   000200   ........     BRA     #??commandTree_6
    122                      }
    123                    }
    124                    else if(commandBuffer[i+SIXTH_ELEMENT]=='S'){ //checking for .BS
   \                     ??commandTree_19:
   \   000204   1F42....     MOV.W   &i, R15
   \   000208   FF905300.... CMP.B   #0x53, commandBuffer + 5(R15)
   \   00020E   2220         JNE     ??commandTree_21
    125                      if(commandBuffer[i+SEVENTH_ELEMENT]=='\r' || commandBuffer[i+SEVENTH_ELEMENT]=='.' || commandBuffer[i+SEVENTH_ELEMENT]=='\n'){ //check for end of a command line
   \   000210   1F42....     MOV.W   &i, R15
   \   000214   FF900D00.... CMP.B   #0xd, commandBuffer + 6(R15)
   \   00021A   0E24         JEQ     ??commandTree_22
   \   00021C   1F42....     MOV.W   &i, R15
   \   000220   FF902E00.... CMP.B   #0x2e, commandBuffer + 6(R15)
   \   000226   0824         JEQ     ??commandTree_22
   \   000228   1F42....     MOV.W   &i, R15
   \   00022C   FF900A00.... CMP.B   #0xa, commandBuffer + 6(R15)
   \   000232   ....         JEQ     $+6
   \   000234   ........     BRA     #??commandTree_6
    126                          display_1 = "   9600   ";
   \                     ??commandTree_22:
   \   000238   B240........ MOV.W   #`?<Constant "   9600   ">`, &display_1
    127                          Init_Serial_UCA1(IOT_9600); //set IOT baud to 9600
   \   00023E   1C43         MOV.W   #0x1, R12
   \   000240   ........     CALLA   #Init_Serial_UCA1
    128                          uart_puts("9600\n");
   \   000244   3C40....     MOV.W   #`?<Constant "9600\\n">`, R12
   \   000248   ........     CALLA   #uart_puts
    129                          StartCommandFG=FALSE;
   \   00024C   8243....     MOV.W   #0x0, &StartCommandFG
   \   000250   ........     BRA     #??commandTree_6
    130                      }
    131                    }  
    132                    else if(numberBuff[FIRST_ELEMENT] != '\0'){ //checking for .B(number)
   \                     ??commandTree_21:
   \   000254   C293....     CMP.B   #0x0, &numberBuff
   \   000258   ....         JNE     $+6
   \   00025A   ........     BRA     #??commandTree_6
    133                        display_1 = "  Reverse ";
   \   00025E   B240........ MOV.W   #`?<Constant "  Reverse ">`, &display_1
    134                        time = atoi(numberBuff);
   \   000264   3C40....     MOV.W   #numberBuff, R12
   \   000268   ........     CALLA   #atoi
   \   00026C   824C....     MOV.W   R12, &time
    135                        time /= FIVE_MSEC;
   \   000270   1C42....     MOV.W   &time, R12
   \   000274   3E400500     MOV.W   #0x5, R14
   \   000278   ........     CALLA   #?DivMod16u
   \   00027C   824C....     MOV.W   R12, &time
    136                        left_reverse_rate         = FORTYFOUR_PERCENT;
   \   000280   B240AC0D.... MOV.W   #0xdac, &left_reverse_rate
    137                        right_reverse_rate        = FORTYFOUR_PERCENT;
   \   000286   B240AC0D.... MOV.W   #0xdac, &right_reverse_rate
    138                        left_wheel_reverse_on();
   \   00028C   ........     CALLA   #left_wheel_reverse_on
    139                        right_wheel_reverse_on();
   \   000290   ........     CALLA   #right_wheel_reverse_on
    140                        Five_msec_Delay(time);
   \   000294   1C42....     MOV.W   &time, R12
   \   000298   ........     CALLA   #Five_msec_Delay
    141                        left_wheel_reverse_off();
   \   00029C   ........     CALLA   #left_wheel_reverse_off
    142                        right_wheel_reverse_off();
   \   0002A0   ........     CALLA   #right_wheel_reverse_off
    143                        Five_msec_Delay(TRUE);
   \   0002A4   1C43         MOV.W   #0x1, R12
   \   0002A6   ........     CALLA   #Five_msec_Delay
   \   0002AA   ........     BRA     #??commandTree_6
    144                      }
    145                  }   
    146                  else if(commandBuffer[i+FIFTH_ELEMENT]=='F'){ //Wheel forward command check
   \                     ??commandTree_15:
   \   0002AE   1F42....     MOV.W   &i, R15
   \   0002B2   FF904600.... CMP.B   #0x46, commandBuffer + 4(R15)
   \   0002B8   8E20         JNE     ??commandTree_23
    147                    k=RESET;
   \   0002BA   8243....     MOV.W   #0x0, &k
    148                    j=i+SIXTH_ELEMENT;
   \   0002BE   1F42....     MOV.W   &i, R15
   \   0002C2   3F500500     ADD.W   #0x5, R15
   \   0002C6   824F....     MOV.W   R15, &j
    149                    for(;commandBuffer[j]!='\r' &&  commandBuffer[j]!='\n' && commandBuffer[j]!='.';j++){
   \                     ??commandTree_3:
   \   0002CA   1F42....     MOV.W   &j, R15
   \   0002CE   FF900D00.... CMP.B   #0xd, commandBuffer(R15)
   \   0002D4   5424         JEQ     ??commandTree_24
   \   0002D6   1F42....     MOV.W   &j, R15
   \   0002DA   FF900A00.... CMP.B   #0xa, commandBuffer(R15)
   \   0002E0   4E24         JEQ     ??commandTree_24
   \   0002E2   1F42....     MOV.W   &j, R15
   \   0002E6   FF902E00.... CMP.B   #0x2e, commandBuffer(R15)
   \   0002EC   4824         JEQ     ??commandTree_24
    150                      if(commandBuffer[j] == '0' || commandBuffer[j] == '1'|| commandBuffer[j] == '2'|| commandBuffer[j] == '3'|| commandBuffer[j] == '4'|| commandBuffer[j] == '5'|| commandBuffer[j] == '6'|| commandBuffer[j] == '7'|| commandBuffer[j] == '8'|| commandBuffer[j] == '9'){
   \   0002EE   1F42....     MOV.W   &j, R15
   \   0002F2   FF903000.... CMP.B   #0x30, commandBuffer(R15)
   \   0002F8   3624         JEQ     ??commandTree_25
   \   0002FA   1F42....     MOV.W   &j, R15
   \   0002FE   FF903100.... CMP.B   #0x31, commandBuffer(R15)
   \   000304   3024         JEQ     ??commandTree_25
   \   000306   1F42....     MOV.W   &j, R15
   \   00030A   FF903200.... CMP.B   #0x32, commandBuffer(R15)
   \   000310   2A24         JEQ     ??commandTree_25
   \   000312   1F42....     MOV.W   &j, R15
   \   000316   FF903300.... CMP.B   #0x33, commandBuffer(R15)
   \   00031C   2424         JEQ     ??commandTree_25
   \   00031E   1F42....     MOV.W   &j, R15
   \   000322   FF903400.... CMP.B   #0x34, commandBuffer(R15)
   \   000328   1E24         JEQ     ??commandTree_25
   \   00032A   1F42....     MOV.W   &j, R15
   \   00032E   FF903500.... CMP.B   #0x35, commandBuffer(R15)
   \   000334   1824         JEQ     ??commandTree_25
   \   000336   1F42....     MOV.W   &j, R15
   \   00033A   FF903600.... CMP.B   #0x36, commandBuffer(R15)
   \   000340   1224         JEQ     ??commandTree_25
   \   000342   1F42....     MOV.W   &j, R15
   \   000346   FF903700.... CMP.B   #0x37, commandBuffer(R15)
   \   00034C   0C24         JEQ     ??commandTree_25
   \   00034E   1F42....     MOV.W   &j, R15
   \   000352   FF903800.... CMP.B   #0x38, commandBuffer(R15)
   \   000358   0624         JEQ     ??commandTree_25
   \   00035A   1F42....     MOV.W   &j, R15
   \   00035E   FF903900.... CMP.B   #0x39, commandBuffer(R15)
   \   000364   0920         JNE     ??commandTree_26
    151                        numberBuff[k] = commandBuffer[j]; // grabbing numbers from command
   \                     ??commandTree_25:
   \   000366   1F42....     MOV.W   &j, R15
   \   00036A   1E42....     MOV.W   &k, R14
   \   00036E   DE4F........ MOV.B   commandBuffer(R15), numberBuff(R14)
    152                        k++;
   \   000374   9253....     ADD.W   #0x1, &k
    153                      }
    154                    }
   \                     ??commandTree_26:
   \   000378   9253....     ADD.W   #0x1, &j
   \   00037C   A63F         JMP     ??commandTree_3
    155                    if(numberBuff[RESET] != '\0'){ //checking for .F(number)
   \                     ??commandTree_24:
   \   00037E   C293....     CMP.B   #0x0, &numberBuff
   \   000382   D125         JEQ     ??commandTree_6
    156                      display_1 = "  Forward ";  
   \   000384   B240........ MOV.W   #`?<Constant "  Forward ">`, &display_1
    157                      time = atoi(numberBuff);
   \   00038A   3C40....     MOV.W   #numberBuff, R12
   \   00038E   ........     CALLA   #atoi
   \   000392   824C....     MOV.W   R12, &time
    158                        startTrackFG = TRUE;
   \   000396   9243....     MOV.W   #0x1, &startTrackFG
    159                        time /= FIVE_MSEC;
   \   00039A   1C42....     MOV.W   &time, R12
   \   00039E   3E400500     MOV.W   #0x5, R14
   \   0003A2   ........     CALLA   #?DivMod16u
   \   0003A6   824C....     MOV.W   R12, &time
    160                        left_forward_rate         = FORTYFOUR_PERCENT;
   \   0003AA   B240AC0D.... MOV.W   #0xdac, &left_forward_rate
    161                        right_forward_rate        = FORTYFOUR_PERCENT;
   \   0003B0   B240AC0D.... MOV.W   #0xdac, &right_forward_rate
    162                        left_wheel_forward_on();
   \   0003B6   ........     CALLA   #left_wheel_forward_on
    163                        right_wheel_forward_on();
   \   0003BA   ........     CALLA   #right_wheel_forward_on
    164                        Five_msec_Delay(time);
   \   0003BE   1C42....     MOV.W   &time, R12
   \   0003C2   ........     CALLA   #Five_msec_Delay
    165                        left_wheel_forward_off();
   \   0003C6   ........     CALLA   #left_wheel_forward_off
    166                        right_wheel_forward_off();
   \   0003CA   ........     CALLA   #right_wheel_forward_off
    167                        Five_msec_Delay(TRUE);
   \   0003CE   1C43         MOV.W   #0x1, R12
   \   0003D0   ........     CALLA   #Five_msec_Delay
   \   0003D4   A83D         JMP     ??commandTree_6
    168                      }
    169                  }   
    170                  else if(commandBuffer[i+FIFTH_ELEMENT]=='R'){ // HARDWARE RESET or turn right command
   \                     ??commandTree_23:
   \   0003D6   1F42....     MOV.W   &i, R15
   \   0003DA   FF905200.... CMP.B   #0x52, commandBuffer + 4(R15)
   \   0003E0   AA20         JNE     ??commandTree_27
    171                      k=RESET;
   \   0003E2   8243....     MOV.W   #0x0, &k
    172                      j=i+SIXTH_ELEMENT;
   \   0003E6   1F42....     MOV.W   &i, R15
   \   0003EA   3F500500     ADD.W   #0x5, R15
   \   0003EE   824F....     MOV.W   R15, &j
    173                      for(;commandBuffer[j]!='\r' &&  commandBuffer[j]!='\n' && commandBuffer[j]!='.';j++){
   \                     ??commandTree_4:
   \   0003F2   1F42....     MOV.W   &j, R15
   \   0003F6   FF900D00.... CMP.B   #0xd, commandBuffer(R15)
   \   0003FC   5424         JEQ     ??commandTree_28
   \   0003FE   1F42....     MOV.W   &j, R15
   \   000402   FF900A00.... CMP.B   #0xa, commandBuffer(R15)
   \   000408   4E24         JEQ     ??commandTree_28
   \   00040A   1F42....     MOV.W   &j, R15
   \   00040E   FF902E00.... CMP.B   #0x2e, commandBuffer(R15)
   \   000414   4824         JEQ     ??commandTree_28
    174                          if(commandBuffer[j] == '0' || commandBuffer[j] == '1'|| commandBuffer[j] == '2'|| commandBuffer[j] == '3'|| commandBuffer[j] == '4'|| commandBuffer[j] == '5'|| commandBuffer[j] == '6'|| commandBuffer[j] == '7'|| commandBuffer[j] == '8'|| commandBuffer[j] == '9'){
   \   000416   1F42....     MOV.W   &j, R15
   \   00041A   FF903000.... CMP.B   #0x30, commandBuffer(R15)
   \   000420   3624         JEQ     ??commandTree_29
   \   000422   1F42....     MOV.W   &j, R15
   \   000426   FF903100.... CMP.B   #0x31, commandBuffer(R15)
   \   00042C   3024         JEQ     ??commandTree_29
   \   00042E   1F42....     MOV.W   &j, R15
   \   000432   FF903200.... CMP.B   #0x32, commandBuffer(R15)
   \   000438   2A24         JEQ     ??commandTree_29
   \   00043A   1F42....     MOV.W   &j, R15
   \   00043E   FF903300.... CMP.B   #0x33, commandBuffer(R15)
   \   000444   2424         JEQ     ??commandTree_29
   \   000446   1F42....     MOV.W   &j, R15
   \   00044A   FF903400.... CMP.B   #0x34, commandBuffer(R15)
   \   000450   1E24         JEQ     ??commandTree_29
   \   000452   1F42....     MOV.W   &j, R15
   \   000456   FF903500.... CMP.B   #0x35, commandBuffer(R15)
   \   00045C   1824         JEQ     ??commandTree_29
   \   00045E   1F42....     MOV.W   &j, R15
   \   000462   FF903600.... CMP.B   #0x36, commandBuffer(R15)
   \   000468   1224         JEQ     ??commandTree_29
   \   00046A   1F42....     MOV.W   &j, R15
   \   00046E   FF903700.... CMP.B   #0x37, commandBuffer(R15)
   \   000474   0C24         JEQ     ??commandTree_29
   \   000476   1F42....     MOV.W   &j, R15
   \   00047A   FF903800.... CMP.B   #0x38, commandBuffer(R15)
   \   000480   0624         JEQ     ??commandTree_29
   \   000482   1F42....     MOV.W   &j, R15
   \   000486   FF903900.... CMP.B   #0x39, commandBuffer(R15)
   \   00048C   0920         JNE     ??commandTree_30
    175                              numberBuff[k] = commandBuffer[j]; // grabbing numbers from command
   \                     ??commandTree_29:
   \   00048E   1F42....     MOV.W   &j, R15
   \   000492   1E42....     MOV.W   &k, R14
   \   000496   DE4F........ MOV.B   commandBuffer(R15), numberBuff(R14)
    176                              k++;
   \   00049C   9253....     ADD.W   #0x1, &k
    177                          }
    178                      }
   \                     ??commandTree_30:
   \   0004A0   9253....     ADD.W   #0x1, &j
   \   0004A4   A63F         JMP     ??commandTree_4
    179                      if(commandBuffer[i+SIXTH_ELEMENT]=='\r' || commandBuffer[i+SIXTH_ELEMENT]=='.' || commandBuffer[i+SIXTH_ELEMENT]=='\n'){ //check for end of a command line
   \                     ??commandTree_28:
   \   0004A6   1F42....     MOV.W   &i, R15
   \   0004AA   FF900D00.... CMP.B   #0xd, commandBuffer + 5(R15)
   \   0004B0   0C24         JEQ     ??commandTree_31
   \   0004B2   1F42....     MOV.W   &i, R15
   \   0004B6   FF902E00.... CMP.B   #0x2e, commandBuffer + 5(R15)
   \   0004BC   0624         JEQ     ??commandTree_31
   \   0004BE   1F42....     MOV.W   &i, R15
   \   0004C2   FF900A00.... CMP.B   #0xa, commandBuffer + 5(R15)
   \   0004C8   0C20         JNE     ??commandTree_32
    180                          display_1 = "  Reset   ";
   \                     ??commandTree_31:
   \   0004CA   B240........ MOV.W   #`?<Constant "  Reset   ">`, &display_1
    181                          IOTHardwareReset(); //resetting iot using pin
   \   0004D0   ........     CALLA   #IOTHardwareReset
    182                          uart_puts("Hardware Reset");
   \   0004D4   3C40....     MOV.W   #`?<Constant "Hardware Reset">`, R12
   \   0004D8   ........     CALLA   #uart_puts
    183                          StartCommandFG=FALSE;
   \   0004DC   8243....     MOV.W   #0x0, &StartCommandFG
   \   0004E0   223D         JMP     ??commandTree_6
    184                      }
    185                      else if(numberBuff[RESET] != '\0'){
   \                     ??commandTree_32:
   \   0004E2   C293....     CMP.B   #0x0, &numberBuff
   \   0004E6   1F25         JEQ     ??commandTree_6
    186                        display_1 = "  Right   ";
   \   0004E8   B240........ MOV.W   #`?<Constant "  Right   ">`, &display_1
    187                        time = atoi(numberBuff); //string to number
   \   0004EE   3C40....     MOV.W   #numberBuff, R12
   \   0004F2   ........     CALLA   #atoi
   \   0004F6   824C....     MOV.W   R12, &time
    188                        time *= DEGREE_RATIO; //multiplying to enable degrees to be entered 
   \   0004FA   1C42....     MOV.W   &time, R12
   \   0004FE   0D43         MOV.W   #0x0, R13
   \   000500   ........     CALLA   #_Cast32uto32f
   \   000504   3E402A8E     MOV.W   #0x8e2a, R14
   \   000508   3F40233F     MOV.W   #0x3f23, R15
   \   00050C   ........     CALLA   #_Mul32f
   \   000510   ........     CALLA   #_Cast32fto32u
   \   000514   824C....     MOV.W   R12, &time
    189                        left_forward_rate = THIRTYEIGHT_PERCENT;
   \   000518   B240B80B.... MOV.W   #0xbb8, &left_forward_rate
    190                        left_wheel_forward_on();
   \   00051E   ........     CALLA   #left_wheel_forward_on
    191                        Five_msec_Delay(time);
   \   000522   1C42....     MOV.W   &time, R12
   \   000526   ........     CALLA   #Five_msec_Delay
    192                        left_wheel_forward_off();
   \   00052A   ........     CALLA   #left_wheel_forward_off
    193                        Five_msec_Delay(TRUE);
   \   00052E   1C43         MOV.W   #0x1, R12
   \   000530   ........     CALLA   #Five_msec_Delay
   \   000534   F83C         JMP     ??commandTree_6
    194                      }
    195                  }
    196                  else if(commandBuffer[i+FIFTH_ELEMENT]=='L'){ // (HARDWARE RESET) or turn left command
   \                     ??commandTree_27:
   \   000536   1F42....     MOV.W   &i, R15
   \   00053A   FF904C00.... CMP.B   #0x4c, commandBuffer + 4(R15)
   \   000540   8C20         JNE     ??commandTree_33
    197                      k=RESET;
   \   000542   8243....     MOV.W   #0x0, &k
    198                      j=i+SIXTH_ELEMENT;
   \   000546   1F42....     MOV.W   &i, R15
   \   00054A   3F500500     ADD.W   #0x5, R15
   \   00054E   824F....     MOV.W   R15, &j
    199                      for(;commandBuffer[j]!='\r' &&  commandBuffer[j]!='\n' && commandBuffer[j]!='.';j++){
   \                     ??commandTree_5:
   \   000552   1F42....     MOV.W   &j, R15
   \   000556   FF900D00.... CMP.B   #0xd, commandBuffer(R15)
   \   00055C   5424         JEQ     ??commandTree_34
   \   00055E   1F42....     MOV.W   &j, R15
   \   000562   FF900A00.... CMP.B   #0xa, commandBuffer(R15)
   \   000568   4E24         JEQ     ??commandTree_34
   \   00056A   1F42....     MOV.W   &j, R15
   \   00056E   FF902E00.... CMP.B   #0x2e, commandBuffer(R15)
   \   000574   4824         JEQ     ??commandTree_34
    200                          if(commandBuffer[j] == '0' || commandBuffer[j] == '1'|| commandBuffer[j] == '2'|| commandBuffer[j] == '3'|| commandBuffer[j] == '4'|| commandBuffer[j] == '5'|| commandBuffer[j] == '6'|| commandBuffer[j] == '7'|| commandBuffer[j] == '8'|| commandBuffer[j] == '9'){
   \   000576   1F42....     MOV.W   &j, R15
   \   00057A   FF903000.... CMP.B   #0x30, commandBuffer(R15)
   \   000580   3624         JEQ     ??commandTree_35
   \   000582   1F42....     MOV.W   &j, R15
   \   000586   FF903100.... CMP.B   #0x31, commandBuffer(R15)
   \   00058C   3024         JEQ     ??commandTree_35
   \   00058E   1F42....     MOV.W   &j, R15
   \   000592   FF903200.... CMP.B   #0x32, commandBuffer(R15)
   \   000598   2A24         JEQ     ??commandTree_35
   \   00059A   1F42....     MOV.W   &j, R15
   \   00059E   FF903300.... CMP.B   #0x33, commandBuffer(R15)
   \   0005A4   2424         JEQ     ??commandTree_35
   \   0005A6   1F42....     MOV.W   &j, R15
   \   0005AA   FF903400.... CMP.B   #0x34, commandBuffer(R15)
   \   0005B0   1E24         JEQ     ??commandTree_35
   \   0005B2   1F42....     MOV.W   &j, R15
   \   0005B6   FF903500.... CMP.B   #0x35, commandBuffer(R15)
   \   0005BC   1824         JEQ     ??commandTree_35
   \   0005BE   1F42....     MOV.W   &j, R15
   \   0005C2   FF903600.... CMP.B   #0x36, commandBuffer(R15)
   \   0005C8   1224         JEQ     ??commandTree_35
   \   0005CA   1F42....     MOV.W   &j, R15
   \   0005CE   FF903700.... CMP.B   #0x37, commandBuffer(R15)
   \   0005D4   0C24         JEQ     ??commandTree_35
   \   0005D6   1F42....     MOV.W   &j, R15
   \   0005DA   FF903800.... CMP.B   #0x38, commandBuffer(R15)
   \   0005E0   0624         JEQ     ??commandTree_35
   \   0005E2   1F42....     MOV.W   &j, R15
   \   0005E6   FF903900.... CMP.B   #0x39, commandBuffer(R15)
   \   0005EC   0920         JNE     ??commandTree_36
    201                              numberBuff[k] = commandBuffer[j]; // grabbing numbers from command
   \                     ??commandTree_35:
   \   0005EE   1F42....     MOV.W   &j, R15
   \   0005F2   1E42....     MOV.W   &k, R14
   \   0005F6   DE4F........ MOV.B   commandBuffer(R15), numberBuff(R14)
    202                              k++;
   \   0005FC   9253....     ADD.W   #0x1, &k
    203                          }
    204                      }
   \                     ??commandTree_36:
   \   000600   9253....     ADD.W   #0x1, &j
   \   000604   A63F         JMP     ??commandTree_5
    205                      if(numberBuff[FIRST_ELEMENT] != '\0'){
   \                     ??commandTree_34:
   \   000606   C293....     CMP.B   #0x0, &numberBuff
   \   00060A   8D24         JEQ     ??commandTree_6
    206                        display_1 = "   Left   ";
   \   00060C   B240........ MOV.W   #`?<Constant "   Left   ">`, &display_1
    207                        time = atoi(numberBuff); //string to number
   \   000612   3C40....     MOV.W   #numberBuff, R12
   \   000616   ........     CALLA   #atoi
   \   00061A   824C....     MOV.W   R12, &time
    208                        time *= DEGREE_RATIO; 
   \   00061E   1C42....     MOV.W   &time, R12
   \   000622   0D43         MOV.W   #0x0, R13
   \   000624   ........     CALLA   #_Cast32uto32f
   \   000628   3E402A8E     MOV.W   #0x8e2a, R14
   \   00062C   3F40233F     MOV.W   #0x3f23, R15
   \   000630   ........     CALLA   #_Mul32f
   \   000634   ........     CALLA   #_Cast32fto32u
   \   000638   824C....     MOV.W   R12, &time
    209                        right_forward_rate = THIRTYEIGHT_PERCENT;
   \   00063C   B240B80B.... MOV.W   #0xbb8, &right_forward_rate
    210                        right_wheel_forward_on();
   \   000642   ........     CALLA   #right_wheel_forward_on
    211                        Five_msec_Delay(time);
   \   000646   1C42....     MOV.W   &time, R12
   \   00064A   ........     CALLA   #Five_msec_Delay
    212                        right_wheel_forward_off();
   \   00064E   ........     CALLA   #right_wheel_forward_off
    213                        Five_msec_Delay(TRUE);
   \   000652   1C43         MOV.W   #0x1, R12
   \   000654   ........     CALLA   #Five_msec_Delay
   \   000658   663C         JMP     ??commandTree_6
    214                      }
    215                  }   
    216                  else if(commandBuffer[i+FIFTH_ELEMENT]=='C'){ //Configure IOT
   \                     ??commandTree_33:
   \   00065A   1F42....     MOV.W   &i, R15
   \   00065E   FF904300.... CMP.B   #0x43, commandBuffer + 4(R15)
   \   000664   3120         JNE     ??commandTree_37
    217                      if(commandBuffer[i+SIXTH_ELEMENT]=='\r' || commandBuffer[i+SIXTH_ELEMENT]=='.' || commandBuffer[i+SIXTH_ELEMENT]=='\n'){ //check for end of a command line
   \   000666   1F42....     MOV.W   &i, R15
   \   00066A   FF900D00.... CMP.B   #0xd, commandBuffer + 5(R15)
   \   000670   0C24         JEQ     ??commandTree_38
   \   000672   1F42....     MOV.W   &i, R15
   \   000676   FF902E00.... CMP.B   #0x2e, commandBuffer + 5(R15)
   \   00067C   0624         JEQ     ??commandTree_38
   \   00067E   1F42....     MOV.W   &i, R15
   \   000682   FF900A00.... CMP.B   #0xa, commandBuffer + 5(R15)
   \   000688   4E20         JNE     ??commandTree_6
    218                          Init_Serial_UCA1(IOT_115200); //Set A1 to 115200. TEMPORARILY SET TO 9600 SO IOT RESPONSE CAN BE SEEN ON TERMINAL
   \                     ??commandTree_38:
   \   00068A   0C43         MOV.W   #0x0, R12
   \   00068C   ........     CALLA   #Init_Serial_UCA1
    219                          uart_puts("AT+S.SCFG=console1_speed,9600\r"); //set IOT baud rate to 9600
   \   000690   3C40....     MOV.W   #`?<Constant "AT+S.SCFG=console1_sp...">`, R12
   \   000694   ........     CALLA   #uart_puts
    220                          Five_msec_Delay(FOR_TWO_SECOND); //delay 2 seconds to allow change to take effect
   \   000698   3C409001     MOV.W   #0x190, R12
   \   00069C   ........     CALLA   #Five_msec_Delay
    221                          uart_puts("AT&W\r"); //save settings to FRAM
   \   0006A0   3C40....     MOV.W   #`?<Constant "AT&W\\r">`, R12
   \   0006A4   ........     CALLA   #uart_puts
    222                          Five_msec_Delay(FOR_ONE_SECOND); //delay 1 second to allow change to take effect
   \   0006A8   3C40C800     MOV.W   #0xc8, R12
   \   0006AC   ........     CALLA   #Five_msec_Delay
    223                          Init_Serial_UCA1(IOT_9600); //Set A1 to 9600 baud
   \   0006B0   1C43         MOV.W   #0x1, R12
   \   0006B2   ........     CALLA   #Init_Serial_UCA1
    224                          uart_puts("AT+CFUN=1\r"); //Send software reset command
   \   0006B6   3C40....     MOV.W   #`?<Constant "AT+CFUN=1\\r">`, R12
   \   0006BA   ........     CALLA   #uart_puts
    225                          IOTHardwareReset(); //resetting iot using pin
   \   0006BE   ........     CALLA   #IOTHardwareReset
    226          
    227                          StartCommandFG=FALSE;
   \   0006C2   8243....     MOV.W   #0x0, &StartCommandFG
   \   0006C6   2F3C         JMP     ??commandTree_6
    228                      }
    229                  }
    230                  
    231                  
    232                  else if(commandBuffer[i+FIFTH_ELEMENT]=='G'){ //blackline dection GO
   \                     ??commandTree_37:
   \   0006C8   1F42....     MOV.W   &i, R15
   \   0006CC   FF904700.... CMP.B   #0x47, commandBuffer + 4(R15)
   \   0006D2   2920         JNE     ??commandTree_6
    233                      if(commandBuffer[i+SIXTH_ELEMENT]=='\r' || commandBuffer[i+SIXTH_ELEMENT]=='.' || commandBuffer[i+SIXTH_ELEMENT]=='\n'){ //check for end of a command line
   \   0006D4   1F42....     MOV.W   &i, R15
   \   0006D8   FF900D00.... CMP.B   #0xd, commandBuffer + 5(R15)
   \   0006DE   0C24         JEQ     ??commandTree_39
   \   0006E0   1F42....     MOV.W   &i, R15
   \   0006E4   FF902E00.... CMP.B   #0x2e, commandBuffer + 5(R15)
   \   0006EA   0624         JEQ     ??commandTree_39
   \   0006EC   1F42....     MOV.W   &i, R15
   \   0006F0   FF900A00.... CMP.B   #0xa, commandBuffer + 5(R15)
   \   0006F6   1720         JNE     ??commandTree_6
    234                          display_1 = " Blk Line ";
   \                     ??commandTree_39:
   \   0006F8   B240........ MOV.W   #`?<Constant " Blk Line ">`, &display_1
    235                          IR_LED_ON(); //IR on
   \   0006FE   ........     CALLA   #IR_LED_ON
    236                          Five_msec_Delay(FOR_TENTH_SECOND); //let IR "warm up"
   \   000702   3C401400     MOV.W   #0x14, R12
   \   000706   ........     CALLA   #Five_msec_Delay
    237                          startBlackLine = TRUE; // set flag for detection true
   \   00070A   9243....     MOV.W   #0x1, &startBlackLine
    238                          if((ADC_Left_Detector) < thresholdL && ADC_Right_Detector < thresholdR){ //does my car start on white or black
   \   00070E   9292........ CMP.W   &thresholdL, &ADC_Left_Detector
   \   000714   062C         JC      ??commandTree_40
   \   000716   9292........ CMP.W   &thresholdR, &ADC_Right_Detector
   \   00071C   022C         JC      ??commandTree_40
    239                            start_on_whiteFG = TRUE;
   \   00071E   9243....     MOV.W   #0x1, &start_on_whiteFG
    240                          }
    241                          
    242                          StartCommandFG=FALSE;
   \                     ??commandTree_40:
   \   000722   8243....     MOV.W   #0x0, &StartCommandFG
    243                      }
    244                  }
    245                  
    246                  
    247          
    248                  for(;commandBuffer[i]!='\r' &&  commandBuffer[i]!='\n' && commandBuffer[i]!='.';i++){
   \                     ??commandTree_6:
   \   000726   1F42....     MOV.W   &i, R15
   \   00072A   FF900D00.... CMP.B   #0xd, commandBuffer(R15)
   \   000730   0F24         JEQ     ??commandTree_41
   \   000732   1F42....     MOV.W   &i, R15
   \   000736   FF900A00.... CMP.B   #0xa, commandBuffer(R15)
   \   00073C   0924         JEQ     ??commandTree_41
   \   00073E   1F42....     MOV.W   &i, R15
   \   000742   FF902E00.... CMP.B   #0x2e, commandBuffer(R15)
   \   000748   0324         JEQ     ??commandTree_41
   \   00074A   9253....     ADD.W   #0x1, &i
   \   00074E   EB3F         JMP     ??commandTree_6
    249                      //this for loop is for incrementing i to the next period
    250                  }
    251                  if(commandBuffer[i]=='.'){ //if not breaking out of while loop, increment i to skip the period part of the next command
   \                     ??commandTree_41:
   \   000750   1F42....     MOV.W   &i, R15
   \   000754   FF902E00.... CMP.B   #0x2e, commandBuffer(R15)
   \   00075A   ....         JEQ     $+6
   \   00075C   ........     BRA     #??commandTree_7
    252                      i++;
   \   000760   9253....     ADD.W   #0x1, &i
   \   000764   ........     BRA     #??commandTree_7
    253                  }
    254              }
    255              StartCommandFG=FALSE;
   \                     ??commandTree_9:
   \   000768   8243....     MOV.W   #0x0, &StartCommandFG
    256              writeCommandFG=FALSE; //command has been executed.
   \   00076C   8243....     MOV.W   #0x0, &writeCommandFG
    257          }
   \   000770   1001         RETA
    258          

   \                                 In  segment CODE, align 2
    259          void uart_puts(const char *str){
   \                     uart_puts:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    260              if (str != '\0') {
   \   000004   0A93         CMP.W   #0x0, R10
   \   000006   1024         JEQ     ??uart_puts_1
    261                  while (*str != '\0') {
   \                     ??uart_puts_0:
   \   000008   CA930000     CMP.B   #0x0, 0(R10)
   \   00000C   0D24         JEQ     ??uart_puts_1
    262                      /* give time for the transmit buffer to be ready */
    263                      Five_msec_Delay(TRUE);
   \   00000E   1C43         MOV.W   #0x1, R12
   \   000010   ........     CALLA   #Five_msec_Delay
    264                      /* Transmit data */
    265                      UCA1TXBUF = *str; //send to IOT
   \   000014   6F4A         MOV.B   @R10, R15
   \   000016   4F4F         MOV.B   R15, R15
   \   000018   824FEE05     MOV.W   R15, &0x5ee
    266                      UCA0TXBUF = *str; //echo to PC
   \   00001C   6F4A         MOV.B   @R10, R15
   \   00001E   4F4F         MOV.B   R15, R15
   \   000020   824FCE05     MOV.W   R15, &0x5ce
    267                      str++;
   \   000024   1A53         ADD.W   #0x1, R10
   \   000026   F03F         JMP     ??uart_puts_0
    268                  }
    269              }
    270          }
   \                     ??uart_puts_1:
   \   000028   3A41         POP.W   R10
   \   00002A   1001         RETA
   \   00002C                REQUIRE _A_UCA1TXBUF_L
   \   00002C                REQUIRE _A_UCA0TXBUF_L

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "I\\'m Here\\r">`:
   \   000000   49276D204865 DC8 "I'm Here\015"
   \            72650D00    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  115200  ">`:
   \   000000   202031313532 DC8 "  115200  "
   \            3030202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "115,200\\n">`:
   \   000000   3131352C3230 DC8 "115,200\012"
   \            300A00      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "   9600   ">`:
   \   000000   202020393630 DC8 "   9600   "
   \            3020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "9600\\n">`:
   \   000000   393630300A00 DC8 "9600\012"

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  Reverse ">`:
   \   000000   202052657665 DC8 "  Reverse "
   \            7273652000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  Forward ">`:
   \   000000   2020466F7277 DC8 "  Forward "
   \            6172642000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  Reset   ">`:
   \   000000   202052657365 DC8 "  Reset   "
   \            7420202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Hardware Reset">`:
   \   000000   486172647761 DC8 "Hardware Reset"
   \            726520526573
   \            657400      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  Right   ">`:
   \   000000   202052696768 DC8 "  Right   "
   \            7420202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "   Left   ">`:
   \   000000   2020204C6566 DC8 "   Left   "
   \            7420202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+S.SCFG=console1_sp...">`:
   \   000000   41542B532E53 DC8 "AT+S.SCFG=console1_speed,9600\015"
   \            4346473D636F
   \            6E736F6C6531
   \            5F7370656564
   \            2C393630300D
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT&W\\r">`:
   \   000000   415426570D00 DC8 "AT&W\015"

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CFUN=1\\r">`:
   \   000000   41542B434655 DC8 "AT+CFUN=1\015"
   \            4E3D310D00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " Blk Line ">`:
   \   000000   20426C6B204C DC8 " Blk Line "
   \            696E652000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   commandTree
        4   -> Five_msec_Delay
        4   -> IOTHardwareReset
        4   -> IR_LED_ON
        4   -> Init_Serial_UCA1
        4   -> _Cast32fto32u
        4   -> _Cast32uto32f
        4   -> _Mul32f
        4   -> atoi
        4   -> left_wheel_forward_off
        4   -> left_wheel_forward_on
        4   -> left_wheel_reverse_off
        4   -> left_wheel_reverse_on
        4   -> right_wheel_forward_off
        4   -> right_wheel_forward_on
        4   -> right_wheel_reverse_off
        4   -> right_wheel_reverse_on
        4   -> uart_puts
        4 ?DivMod16u
      6   uart_puts
        6   -> Five_msec_Delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "   9600   ">
      11  ?<Constant "   Left   ">
      11  ?<Constant "  115200  ">
      11  ?<Constant "  Forward ">
      11  ?<Constant "  Reset   ">
      11  ?<Constant "  Reverse ">
      11  ?<Constant "  Right   ">
      11  ?<Constant " Blk Line ">
       9  ?<Constant "115,200\n">
       6  ?<Constant "9600\n">
       6  ?<Constant "AT&W\r">
      11  ?<Constant "AT+CFUN=1\r">
      31  ?<Constant "AT+S.SCFG=console1_sp...">
      15  ?<Constant "Hardware Reset">
      10  ?<Constant "I\'m Here\r">
       2  _A_UCA0TXBUF_L
       2  _A_UCA1TXBUF_L
    1906  commandTree
       5  numberBuff
       2  startBlackLine
       2  time
      44  uart_puts

 
 1 950 bytes in segment CODE
     4 bytes in segment DATA16_AN
   176 bytes in segment DATA16_C
     9 bytes in segment DATA16_Z
 
 1 950 bytes of CODE  memory
   176 bytes of CONST memory
     9 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: none
